#!/usr/bin/env python
# Copyright 2014 Scalyr Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------------------
#
# Contains the data structures used to represent a snapshot of the
# agent's status, giving such details as the number of log bytes copied,
# whether or not the configuration file was successfully parsed, etc.
#
# These data structures are generated by the ScalyrAgent's __generate_status
# method and are used to create both the interactive status (which is emitted when
# the 'status -v' command is invoked by the user) and the status periodically recorded
# in the agent log.
#
# author: Steven Czerwinski <czerwin@scalyr.com>

__author__ = 'czerwin@scalyr.com'

import os

import scalyr_agent.util as scalyr_util


class AgentStatus(object):
    """The main status container object, holding references to all other status elements.
    """
    def __init__(self):
        # The time (in seconds past epoch) when the agent process was launched.
        self.launch_time = None
        # The user name the agent process is running under.
        self.user = None
        # The version string for the agent.
        self.version = None
        # The name of the host the agent is running on.
        self.server_host = None
        # The URL of the scalyr server that the agent is connected to (such as https://www.scalyr.com/).
        self.scalyr_server = None
        # The path for the agent's log file.
        self.log_path = None
        # The ConfigStatus object recording the status for the configuration file.
        self.config_status = None
        # The CopyingManagerStatus object recording the status of the log copying manager (or none if CopyingManager
        # has not been started). This contains information about the different log paths being watched and the
        # progress of copying their bytes.
        self.copying_manager_status = None
        # The MonitorManagerStatus object recording the status of the monitor manager (or none if the MonitorManager
        # has not been started).  This contains information about the different ScalyrMonitors being run.
        self.monitor_manager_status = None


class OverallStats(object):
    """Used to track stats that are calculated over the lifetime of the agent.
    """
    def __init__(self):
        # The time in seconds past epoch when the agent was started.
        self.launch_time = None
        # The version string for the agent.
        self.version = None
        # The current number of paths the log copier is watching.
        self.num_watched_paths = 0
        # The current number of file paths the log copier is copying.
        self.num_copying_paths = 0
        # The current number of running monitors.
        self.num_running_monitors = 0
        # The current number of monitors that should be running but are not.
        self.num_dead_monitor = 0
        # The total amount of user time CPU used by the agent (cpu secs).
        self.user_cpu = 0
        # The total amount of system time CPU used by the agent (cpu secs)
        self.system_cpu = 0
        # The current resident size in bytes of the agent process.
        self.rss_size = 0

        # The total number of log bytes copied to the Scalyr servers.
        self.total_bytes_copied = 0
        # The total number of log bytes that were skipped and were not considered to be sent to the Scalyr servers.
        self.total_bytes_skipped = 0
        # The total number of log bytes that were not sent to the Scalyr servers due to subsampling rules.
        self.total_bytes_subsampled = 0
        # The total number of log bytes that were not sent to Scalyr due to errors on either the client or server side.
        self.total_bytes_failed = 0
        # The total number of redactions that were applied to the log lines before being sent to the Scalyr servers.
        self.total_redactions = 0
        # The total number of errors seen when issuing a copy request.
        self.total_copy_requests_errors = 0
        # The total number of lines reported by monitors.
        self.total_monitor_reported_lines = 0
        # The total number of errors seen by executing monitors.
        self.total_monitor_errors = 0

        # The total number of RPC requests sent.
        self.total_requests_sent = 0
        # The total number of RPC requests that failed.
        self.total_requests_failed = 0
        # The total number of bytes sent over the network.
        self.total_request_bytes_sent = 0
        # The total number of compressed bytes sent over the network.
        self.total_compressed_request_bytes_sent = 0
        # The total number of bytes received.
        self.total_response_bytes_received = 0
        # The total number of secs spent waiting for a responses (so average latency can be calculated by dividing
        # this number by self.total_requests_sent).  This includes connection establishment time.
        self.total_request_latency_secs = 0
        # The total number of HTTP connections successfully created.
        self.total_connections_created = 0

    def __add__(self, other):
        """Adds all of the 'total_' fields of this instance and other together and returns a new OverallStats containing
        the result.
        """
        result = OverallStats()
        result.total_bytes_copied = self.total_bytes_copied + other.total_bytes_copied
        result.total_bytes_skipped = self.total_bytes_skipped + other.total_bytes_skipped
        result.total_bytes_subsampled = self.total_bytes_subsampled + other.total_bytes_subsampled
        result.total_bytes_failed = self.total_bytes_failed + other.total_bytes_failed
        result.total_redactions = self.total_redactions + other.total_redactions
        result.total_copy_requests_errors = self.total_copy_requests_errors + other.total_copy_requests_errors
        result.total_monitor_reported_lines = self.total_monitor_reported_lines + other.total_monitor_reported_lines
        result.total_monitor_errors = self.total_monitor_errors + other.total_monitor_errors

        result.total_requests_sent = self.total_requests_sent + other.total_requests_sent
        result.total_requests_failed = self.total_requests_failed + other.total_requests_failed
        result.total_request_bytes_sent = self.total_request_bytes_sent + other.total_request_bytes_sent
        result.total_compressed_request_bytes_sent = self.total_compressed_request_bytes_sent + other.total_compressed_request_bytes_sent
        result.total_response_bytes_received = self.total_response_bytes_received + other.total_response_bytes_received
        result.total_request_latency_secs = self.total_request_latency_secs + other.total_request_latency_secs
        result.total_connections_created = self.total_connections_created + other.total_connections_created

        return result


class ConfigStatus(object):
    """The status pertaining to parsing of the configuration file."""
    def __init__(self):
        # The path of the configuration file.
        self.path = None
        # The paths for additional configuration files read from the config directory.
        self.additional_paths = []
        # The last time the configuration file changed and was read by this agent.
        self.last_read_time = None
        # A status line describing if the configuration file was successfully parsed.
        self.status = None
        # If the status file count not be parsed/used, a string describing the error.
        self.last_error = None
        # The last time the configuration file was successfully parsed.
        self.last_good_read = None
        # The last time the agent checked to see if the configuration file has changed.
        self.last_check_time = None


class CopyingManagerStatus(object):
    """The status object containing information about the agent's copying components."""
    def __init__(self):
        # The total number of bytes successfully uploaded.
        self.total_bytes_uploaded = 0
        # The last time the agent successfully copied bytes from log files to the Scalyr servers.
        self.last_success_time = None
        # The last time the agent attempted to copy bytes from log files to the Scalyr servers.
        self.last_attempt_time = None
        # The size of the request for the last attempt.
        self.last_attempt_size = None
        # The last response from the Scalyr servers.
        self.last_response = None
        # The last status from the last response (should be 'success').
        self.last_response_status = None
        # The total number of failed copy requests.
        self.total_errors = None

        # LogMatcherStatus objects for each of the log paths being watched for copying.
        self.log_matchers = []


class LogMatcherStatus(object):
    """The status object containing information about all of the copying being performed for a particular
    log path including globbing."""
    def __init__(self):
        # The path.
        self.log_path = None
        # True if the log path contains globbing characters.
        self.is_glob = None
        # The last time the agent checked the path for new matches.
        self.last_check_time = None
        # For any matching file paths, a LogProcessorStatus object describing the copying.
        self.log_processors_status = []


class LogProcessorStatus(object):
    """The status object containing information about the progress of the bytes being copied for a particular
    file."""
    def __init__(self):
        # The path of the file (will not contain glob characters).  This will be a path to an existing file.
        self.log_path = None
        # The last time the file was checked for new bytes.
        self.last_scan_time = None
        # The total bytes copied to the Scalyr servers.
        self.total_bytes_copied = 0
        # The number of bytes that still need to be sent to the Scalyr servers.
        self.total_bytes_pending = 0
        # The total bytes that were skipped (due to the log lines being too old, or the agent falling behind).
        self.total_bytes_skipped = 0
        # The total bytes that failed due to errors at either the server or client.
        self.total_bytes_failed = 0
        # The total bytes that were not sent to the server due to subsampling rules.
        self.total_bytes_dropped_by_sampling = 0
        # The total number of log lines copied to the Scalyr servers.
        self.total_lines_copied = 0
        # The total number of log lines that were not sent to the server due to subsampling rules.
        self.total_lines_dropped_by_sampling = 0
        # The total number of redactions applied to the log lines copied to the server.
        self.total_redactions = 0


class MonitorManagerStatus(object):
    """The status object containing information about all of the running monitors."""
    def __init__(self):
        # The total number of monitors that are currently running.
        self.total_alive_monitors = 0
        # The MonitorStatus object for each monitor that is currently running or should be running.
        self.monitors_status = []


class MonitorStatus(object):
    """The status object for a specific instance of a ScalyrMonitor."""
    def __init__(self):
        # The name of the monitor.
        self.monitor_name = None
        # The total number of metric lines reported by the monitor.
        self.reported_lines = 0
        # The total number of errors produced by the monitor.
        self.errors = 0
        # Whether or not the monitor is running.
        self.is_alive = False


def report_status(output, status, current_time):
    print >>output, 'Scalyr Agent status.  See https://www.scalyr.com/help/scalyr-agent-2 for help'
    print >>output, ''
    print >>output, 'Current time:     %s' % scalyr_util.format_time(current_time)
    print >>output, 'Agent started at: %s' % scalyr_util.format_time(status.launch_time)
    print >>output, 'Version:          %s' % status.version
    print >>output, 'Agent running as: %s' % status.user
    print >>output, 'Agent log:        %s' % status.log_path
    print >>output, 'ServerHost:       %s' % status.server_host
    print >>output, ''
    server = status.scalyr_server
    # We default to https://agent.scalyr.com for the Scalyr server, but to see the status on the web,
    # you should go to https://www.scalyr.com.  So, we do a little clean up before sticking it in
    # the url.  Same goes for https://log.scalyr.com  -- it is really is just https://www.scalyr.com
    server = server.replace('https://agent.', 'https://www.')
    server = server.replace('https://log.', 'https://www.')
    print >>output, 'View data from this agent at: %s/events?filter=$serverHost%%3D%%27%s%%27' % (
        server, status.server_host)
    print >>output, ''
    print >>output, ''

    # Configuration file status:
    print >>output, 'Agent configuration:'
    print >>output, '===================='
    print >>output, ''
    if len(status.config_status.additional_paths) == 0:
        print >>output, 'Configuration file:    %s' % status.config_status.path
    else:
        print >>output, 'Configuration files:   %s' % status.config_status.path
        for x in status.config_status.additional_paths:
            print >>output, '                       %s' % x

    if status.config_status.last_error is None:
        print >>output, 'Status:                Good (files parsed successfully)'
    else:
        print >>output, 'Status:                Bad (could not parse, using last good version)'
    print >>output, 'Last checked:          %s' % scalyr_util.format_time(status.config_status.last_check_time)
    print >>output, 'Last changed observed: %s' % scalyr_util.format_time(status.config_status.last_read_time)

    if status.config_status.last_error is not None:
        print >>output, 'Parsing error:         %s' % str(status.config_status.last_error)

    def print_environment():

        # Print scalyr-related env variables in sorted order with critical variables up top. Redact API key.
        main_keys = ['SCALYR_API_KEY', 'SCALYR_SERVER']
        special_case_keys = set(['K8S_EVENT_DISABLE'])
        redacted_keys = set(['SCALYR_API_KEY'])

        # Make a map of uppercase keys -> relevant environment vars (beginning with SCALYR)
        upper2actualkey = {}
        for k in os.environ.keys():
            kup = k.upper()
            if kup.startswith('SCALYR') or kup in special_case_keys:
                upper2actualkey[kup] = k

        # Sorted list of all scalyr keys, including main_keys which may not be present
        # Sort order does not consider letter case.
        sorted_upperkeys = main_keys + sorted(set(upper2actualkey.keys()) - set(main_keys))

        print >>output, ''
        row = 0
        for kup in sorted_upperkeys:
            key = upper2actualkey.get(kup, kup)
            val = os.getenv(key)
            if not val:
                val = '<Missing>'
            elif key.upper() in redacted_keys:
                val = '<Redacted>'

            if row == 0:
                print >>output, 'Environment variables: %s = %s' % (key, val)
            else:
                print >>output, '                       %s = %s' % (key, val)
            row += 1

    print_environment()

    if status.copying_manager_status is not None:
        print >>output, ''
        print >>output, ''
        __report_copying_manager(output, status.copying_manager_status, status.log_path,
                                 status.config_status.last_read_time)

    if status.monitor_manager_status is not None:
        print >>output, ''
        print >>output, ''
        __report_monitor_manager(output, status.monitor_manager_status, status.config_status.last_read_time)


def __report_copying_manager(output, manager_status, agent_log_file_path, read_time):
    print >>output, 'Log transmission:'
    print >>output, '================='
    print >>output, ''
    print >>output, '(these statistics cover the period from %s)' % scalyr_util.format_time(read_time)
    print >>output, ''

    print >>output, 'Bytes uploaded successfully:               %ld' % manager_status.total_bytes_uploaded
    print >>output, 'Last successful communication with Scalyr: %s' % scalyr_util.format_time(
        manager_status.last_success_time)
    print >>output, 'Last attempt:                              %s' % scalyr_util.format_time(
        manager_status.last_attempt_time)
    if manager_status.last_attempt_size is not None:
        print >>output, 'Last copy request size:                    %ld' % manager_status.last_attempt_size
    if manager_status.last_response is not None:
        print >>output, 'Last copy response size:                   %ld' % len(manager_status.last_response)
        print >>output, 'Last copy response status:                 %s' % manager_status.last_response_status
        if manager_status.last_response_status != 'success':
            print >>output, 'Last copy response:                        %s' % scalyr_util.remove_newlines_and_truncate(
                manager_status.last_response, 1000)
    if manager_status.total_errors > 0:
        print >>output, 'Total responses with errors:               %d (see \'%s\' for details)' % (
            manager_status.total_errors, agent_log_file_path)
    print >>output, ''

    for matcher_status in manager_status.log_matchers:
        if not matcher_status.is_glob:
            if len(matcher_status.log_processors_status) == 0:
                # This is an absolute file path (no wildcards) and there are not matches.
                print >>output, 'Path %s: no matching readable file, last checked %s' % (
                    matcher_status.log_path, scalyr_util.format_time(matcher_status.last_check_time))
            else:
                # We have a match.. matcher_status.log_processors_status should really only have one
                # entry, but we loop anyway.
                for processor_status in matcher_status.log_processors_status:
                    output.write('Path %s: copied %ld bytes (%ld lines), %ld bytes pending, ' % (
                        processor_status.log_path, processor_status.total_bytes_copied,
                        processor_status.total_lines_copied, processor_status.total_bytes_pending))
                    if processor_status.total_bytes_skipped > 0:
                        output.write('%ld bytes skipped, ' % processor_status.total_bytes_skipped)
                    if processor_status.total_bytes_failed > 0:
                        output.write('%ld bytes failed, ' % processor_status.total_bytes_failed)
                    if processor_status.total_bytes_dropped_by_sampling > 0:
                        output.write('%ld bytes dropped by sampling (%ld lines), ' % (
                            processor_status.total_bytes_dropped_by_sampling,
                            processor_status.total_lines_dropped_by_sampling))

                    if processor_status.total_redactions > 0:
                        output.write('%ld redactions, ' % processor_status.total_redactions)
                    output.write('last checked %s' % scalyr_util.format_time(processor_status.last_scan_time))
                    output.write('\n')
                    output.flush()

    need_to_add_extra_line = True
    for matcher_status in manager_status.log_matchers:
        if matcher_status.is_glob:
            if need_to_add_extra_line:
                need_to_add_extra_line = False
                print >>output, ''
            print >>output, 'Glob: %s:: last scanned for glob matches at %s' % (
                matcher_status.log_path, scalyr_util.format_time(matcher_status.last_check_time))

            for processor_status in matcher_status.log_processors_status:
                output.write('  %s: copied %ld bytes (%ld lines), %ld bytes pending, ' % (
                    processor_status.log_path, processor_status.total_bytes_copied,
                    processor_status.total_lines_copied, processor_status.total_bytes_pending))
                if processor_status.total_bytes_skipped > 0:
                    output.write('%ld bytes skipped, ' % processor_status.total_bytes_skipped)
                if processor_status.total_bytes_failed > 0:
                    output.write('%ld bytes failed, ' % processor_status.total_bytes_failed)
                if processor_status.total_bytes_dropped_by_sampling > 0:
                    output.write('%ld bytes dropped by sampling (%ld lines), ' % (
                        processor_status.total_bytes_dropped_by_sampling,
                        processor_status.total_lines_dropped_by_sampling))

                if processor_status.total_redactions > 0:
                    output.write('%ld redactions, ' % processor_status.total_redactions)
                output.write('last checked %s' % scalyr_util.format_time(processor_status.last_scan_time))
                output.write('\n')
                output.flush()


def __report_monitor_manager(output, manager_status, read_time):
    print >>output, 'Monitors:'
    print >>output, '========='
    print >>output, ''
    print >>output, '(these statistics cover the period from %s)' % scalyr_util.format_time(read_time)
    print >>output, ''
    if manager_status.total_alive_monitors < len(manager_status.monitors_status):
        print >>output, 'Running monitors:'
        padding = '  '
    else:
        padding = ''

    for entry in manager_status.monitors_status:
        if entry.is_alive:
            print >>output, '%s%s: %d lines emitted, %d errors' % (
                padding, entry.monitor_name, entry.reported_lines, entry.errors)

    dead_monitors = len(manager_status.monitors_status) - manager_status.total_alive_monitors
    if dead_monitors > 0:
        print >>output, ''
        print >>output, 'Failed monitors:'
        for entry in manager_status.monitors_status:
            if not entry.is_alive:
                print >>output, '  %s %d lines emitted, %d errors' % (
                    entry.monitor_name, entry.reported_lines, entry.errors)
